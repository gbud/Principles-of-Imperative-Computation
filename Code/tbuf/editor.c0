/**************************************************************************/
/*              COPYRIGHT Carnegie Mellon University 2022                 */
/* Do not post this file or any derivative on a public site or repository */
/**************************************************************************/
/*
 * Augment doubly linked lists with row and column information.
 *
 * 15-122 Principles of Imperative Computation */

/*** Interface ***/

typedef struct editor_header editor;
struct editor_header {
  tbuf* buffer;
  int row;
  int col;
};

bool is_editor(editor* E) {
  return E != NULL
      && is_tbuf(E->buffer)
      && E->row == tbuf_row(E->buffer)
      && E->col == tbuf_col(E->buffer);
}

bool is_editor_empty(editor* E)
//@requires is_editor(E);
{
  return is_tbuf_empty(E->buffer)
      && E->row == 1
      && E->col == 0;
}

editor* editor_new()                   /* Creates a new, empty text buffer */
//@ensures is_editor(\result);
//@ensures is_editor_empty(\result);
{
  editor* E = alloc(editor);
  E->buffer = tbuf_new();
  E->row = 1;
  E->col = 0;
  return E;
}

bool valid_forward(editor*E)
//@requires is_editor(E);
{
  return E->buffer->cursor != E->buffer->end;
}

bool valid_back(editor* E)
//@requires is_editor(E);
{
  if (E->col == 0 && E->row == 1) return false;
  else return true;
}

void editor_forward(editor* E)         /* Moves the cursor forward (right) */
//@requires is_editor(E);
//@requires valid_forward(E);
//@ensures is_editor(E);
{
  tbuf_forward(E->buffer);
  if (E->buffer->cursor->prev->data == '\n') {
    E->row ++;
    E->col = 0;
  }
  else E->col ++;
}

void editor_backward(editor* E)        /* Moves the cursor backward (left) */
//@requires is_editor(E);
//@requires valid_back(E);
//@ensures is_editor(E);
{
  tbuf_backward(E->buffer);
  if (E->buffer->cursor->data == '\n') {
    E->row --;
    E->col = tbuf_col(E->buffer);
  }
  else E->col --;
}

void editor_insert(editor* E, char c)  /* Insert a character before cursor */
//@requires is_editor(E);
//@ensures is_editor(E);
{  
  tbuf_insert(E->buffer, c);
  if (c == '\n') {
    E->row ++;
    E->col = 0;
  }
  else E->col ++;
}

void editor_delete(editor* E)          /* Remove character before cursor   */
//@requires is_editor(E);
//@requires valid_back(E);
//@ensures is_editor(E);
{
  if (E->buffer->cursor->prev->data == '\n') {
    tbuf_delete(E->buffer);
    E->row --;
    E->col = tbuf_col(E->buffer);
  }
  else {
    E->col --;  
    tbuf_delete(E->buffer);
  }
}

void editor_up(editor* E)              /* Moves the cursor up              */
//@requires is_editor(E);
//@requires E->row > 1;
//@ensures is_editor(E);
{
  tbuf_backward(E->buffer);
  while (E->buffer->cursor->data != '\n') tbuf_backward(E->buffer);
  int shift = tbuf_col(E->buffer) - E->col;
  if (shift >= 0) for (int i = 0; i < shift; i++) tbuf_backward(E->buffer);
  else E->col = shift + E->col;
  E->row --;
}

// void editor_down(editor* E)            /* Moves the cursor down            */
// //@requires is_editor(E);
// //@ensures is_editor(E);
// {
//   tbuf_forward(E->buffer);
//   while (E->buffer->cursor->data != '\n' 
//         || E->buffer->cursor != E->buffer->end) tbuf_forward(E->buffer);
  
// }
/*** Implementation ***/
